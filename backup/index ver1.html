<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>SkySoar: Multi-Biome</title>
    <meta name="theme-color" content="#0f172a">
    
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ðŸ¦…</text></svg>">

    <style>
        /* --- CSS STYLES --- */
        :root { --primary: #fbbf24; --glass: rgba(0, 0, 0, 0.6); }
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', sans-serif; user-select: none; -webkit-user-select: none; }
        canvas { display: block; width: 100vw; height: 100vh; outline: none; }

        /* CRT SCANLINE EFFECT */
        body::after {
            content: ""; position: absolute; top: 0; left: 0; width: 100vw; height: 100vh;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.1) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.03), rgba(0, 255, 0, 0.01), rgba(0, 0, 255, 0.03));
            background-size: 100% 3px, 3px 100%; pointer-events: none; z-index: 999;
        }

        /* UI ELEMENTS */
        #hud { position: absolute; top: 0; left: 0; width: 100%; padding: 20px; pointer-events: none; z-index: 10; display: flex; justify-content: space-between; box-sizing: border-box; }
        
        .panel { 
            pointer-events: auto; background: var(--glass); backdrop-filter: blur(10px);
            padding: 15px 25px; border-radius: 12px; border: 1px solid rgba(255,255,255,0.15); 
            color: white; box-shadow: 0 4px 20px rgba(0,0,0,0.4); display: flex; flex-direction: column; gap: 5px;
        }
        
        h1 { margin: 0; font-size: 1.5rem; color: var(--primary); font-style: italic; font-weight: 900; letter-spacing: 2px; text-shadow: 0 0 10px rgba(251, 191, 36, 0.5); }
        .sub-text { font-size: 0.75rem; opacity: 0.7; letter-spacing: 1px; }

        /* BUTTONS */
        button { border: none; outline: none; user-select: none; cursor: pointer; font-family: inherit; }

        /* PAUSE MENU */
        #pause-menu { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            background: rgba(0,0,0,0.85); backdrop-filter: blur(8px); z-index: 50;
            display: none; flex-direction: column; justify-content: center; align-items: center; gap: 20px;
        }
        #pause-menu h2 { color: white; font-size: 3rem; margin-bottom: 10px; letter-spacing: 5px; font-weight: 900; }
        
        .btn-menu {
            background: var(--primary); color: black; padding: 15px 40px; border-radius: 30px;
            font-size: 1.2rem; font-weight: bold; transition: transform 0.2s; width: 250px;
        }
        .btn-menu:hover { transform: scale(1.05); }
        .btn-secondary { background: transparent; border: 2px solid white; color: white; }

        /* CONTROLS */
        #controls { position: absolute; bottom: 30px; right: 30px; z-index: 20; display: flex; gap: 15px; pointer-events: none; }
        
        .action-btn { 
            pointer-events: auto; width: 80px; height: 80px; border-radius: 50%; 
            background: rgba(255,255,255,0.1); border: 2px solid rgba(255,255,255,0.3); 
            color: white; font-weight: bold; display: flex; justify-content: center; align-items: center; 
            backdrop-filter: blur(4px); font-size: 0.8rem; transition: all 0.1s;
        }
        .action-btn:active { background: var(--primary); color: black; transform: scale(0.95); border-color: var(--primary); }
        
        #dive-btn { border-color: var(--primary); color: var(--primary); }

        #stamina-wrap { width: 100%; height: 6px; background: #333; margin-top: 10px; border-radius: 3px; overflow: hidden; }
        #stamina-bar { width: 100%; height: 100%; background: linear-gradient(90deg, #f59e0b, #fbbf24); box-shadow: 0 0 15px #fbbf24; transition: width 0.1s; }

        /* MOBILE JOYSTICK */
        #joystick-zone { display: none; }
        @media (hover: none) { 
            #joystick-zone { display: block; position: absolute; bottom: 40px; left: 40px; width: 140px; height: 140px; border: 2px solid rgba(255,255,255,0.1); border-radius: 50%; pointer-events: auto; }
            #joystick-knob { position: absolute; width: 60px; height: 60px; background: rgba(255,255,255,0.2); border-radius: 50%; top: 50%; left: 50%; transform: translate(-50%, -50%); border: 1px solid rgba(255,255,255,0.5); backdrop-filter: blur(2px); }
        }
    </style>
</head>
<body>

    <div id="pause-menu">
        <h2>PAUSED</h2>
        <button class="btn-menu" id="resume-btn">RESUME</button>
        <button class="btn-menu btn-secondary" id="world-btn">CHANGE WORLD</button>
        <div style="color:white; margin-top:10px; opacity:0.7">Current: <span id="world-name">STRATOSPHERE</span></div>
    </div>

    <div id="hud">
        <div class="panel">
            <h1>SKYSOAR</h1>
            <div class="sub-text">ECOSYSTEM SIMULATION</div>
            <div id="stamina-wrap"><div id="stamina-bar"></div></div>
            <div style="margin-top: 5px; font-family: monospace;">
                ALT: <b id="alt">0</b>m | SPD: <b id="spd">0</b>
            </div>
        </div>
        
        <div class="panel" style="align-items: flex-end;">
            <div style="font-size: 2rem; font-weight: 900; color: white;" id="score">0</div>
            <div class="sub-text" style="color: var(--primary);">SCORE</div>
        </div>
    </div>

    <div id="joystick-zone"><div id="joystick-knob"></div></div>
    <div id="controls">
        <button class="action-btn" id="pause-btn">PAUSE</button>
        <button class="action-btn" id="dive-btn">DIVE</button>
    </div>

    <canvas id="game-canvas"></canvas>

    <script type="module">
        import * as THREE from 'https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.module.js';

        // --- BIOME DATA ---
        const BIOMES = [
            { 
                name: "STRATOSPHERE", 
                sky: 0x0f172a, fog: 0x0f172a, ground: 0x1e2f1e, 
                treeColor: 0x1a2f1a, sun: 0xffffff, hemi: 0x444444,
                rain: false
            },
            { 
                name: "GOLDEN HOUR", 
                sky: 0xffaa00, fog: 0xffaa00, ground: 0x2d4c1e, 
                treeColor: 0x132413, sun: 0xffaa33, hemi: 0xffeeb1,
                rain: false
            },
            { 
                name: "STORM CHASER", 
                sky: 0x1e293b, fog: 0x1e293b, ground: 0x0f172a, 
                treeColor: 0x334155, sun: 0xaaccee, hemi: 0x223344,
                rain: true
            },
            { 
                name: "NEON GRID", 
                sky: 0x000000, fog: 0x000000, ground: 0x110022, 
                treeColor: 0xff00ff, sun: 0x00ffff, hemi: 0x220022,
                rain: false
            }
        ];

        const TREE_COUNT = 3000;
        const PARTICLE_COUNT = 200;
        const WORLD_SIZE = 6000;

        // --- AUDIO ---
        class AudioController {
            constructor() { this.ctx = null; this.windGain = null; }
            init() {
                if (this.ctx) return;
                const AC = window.AudioContext || window.webkitAudioContext;
                this.ctx = new AC();
                const bSize = 2 * this.ctx.sampleRate;
                const b = this.ctx.createBuffer(1, bSize, this.ctx.sampleRate);
                const d = b.getChannelData(0);
                for(let i=0; i<d.length; i++) d[i] = (Math.random() * 2 - 1) * 0.5;
                
                const src = this.ctx.createBufferSource();
                src.buffer = b; src.loop = true;
                const f = this.ctx.createBiquadFilter();
                f.frequency.value = 400;
                this.windGain = this.ctx.createGain();
                this.windGain.gain.value = 0;
                src.connect(f).connect(this.windGain).connect(this.ctx.destination);
                src.start();
            }
            update(speed) {
                if(!this.windGain) return;
                const vol = Math.min(Math.max(speed - 0.5, 0) / 5, 0.25);
                this.windGain.gain.setTargetAtTime(vol, this.ctx.currentTime, 0.1);
            }
            suspend(isPaused) { if(this.ctx) isPaused ? this.ctx.suspend() : this.ctx.resume(); }
        }

        // --- GAME ENGINE ---
        class Game {
            constructor() {
                this.audio = new AudioController();
                this.input = { x:0, y:0, dive:false, sx:0, sy:0 };
                this.state = { speed:0, stamina:100, score:0, time:0, paused: false, biomeIndex: 0 };
                this.wings = [];
                this.envObjects = []; // Store terrain objects to dispose later
                
                this.initDOM();
                this.init3D();
            }

            initDOM() {
                // World Switcher
                const switchBiome = () => {
                    this.state.biomeIndex = (this.state.biomeIndex + 1) % BIOMES.length;
                    this.loadBiome(this.state.biomeIndex);
                };
                document.getElementById('world-btn').onclick = switchBiome;

                // Pause
                const togglePause = () => {
                    this.state.paused = !this.state.paused;
                    document.getElementById('pause-menu').style.display = this.state.paused ? 'flex' : 'none';
                    this.audio.suspend(this.state.paused);
                };
                document.getElementById('pause-btn').onclick = togglePause;
                document.getElementById('resume-btn').onclick = togglePause;
                window.addEventListener('keydown', e => { if(e.key === 'Escape') togglePause(); });

                // Inputs
                const key = (e, down) => {
                    if(this.state.paused) return;
                    if(down && !this.audio.ctx) this.audio.init();
                    if('ArrowUp,w'.includes(e.key)) this.input.y = down?1:0;
                    if('ArrowDown,s'.includes(e.key)) this.input.y = down?-1:0;
                    if('ArrowLeft,a'.includes(e.key)) this.input.x = down?1:0;
                    if('ArrowRight,d'.includes(e.key)) this.input.x = down?-1:0;
                    if(e.key=='Shift') this.input.dive = down;
                };
                window.addEventListener('keydown', e => key(e, true));
                window.addEventListener('keyup', e => key(e, false));

                // Touch
                const zone = document.getElementById('joystick-zone');
                const knob = document.getElementById('joystick-knob');
                zone.addEventListener('touchstart', e => {
                    if(this.state.paused) return;
                    if(!this.audio.ctx) this.audio.init();
                    this.input.sx = e.touches[0].clientX; this.input.sy = e.touches[0].clientY;
                }, {passive: false});
                zone.addEventListener('touchmove', e => {
                    if(this.state.paused) return;
                    e.preventDefault();
                    const dx = e.touches[0].clientX - this.input.sx;
                    const dy = e.touches[0].clientY - this.input.sy;
                    this.input.x = Math.max(-1, Math.min(1, dx/40));
                    this.input.y = Math.max(-1, Math.min(1, -dy/40));
                    const kx = this.input.x * 40; const ky = this.input.y * -40;
                    knob.style.transform = `translate(calc(-50% + ${kx}px), calc(-50% + ${ky}px))`;
                }, {passive: false});
                zone.addEventListener('touchend', () => { 
                    this.input.x=0; this.input.y=0; 
                    knob.style.transform = `translate(-50%, -50%)`;
                });
                
                // Dive Button
                const dBtn = document.getElementById('dive-btn');
                const startDive = (e) => { e.preventDefault(); if(!this.audio.ctx) this.audio.init(); this.input.dive = true; };
                const endDive = (e) => { e.preventDefault(); this.input.dive = false; };
                dBtn.addEventListener('mousedown', startDive); dBtn.addEventListener('mouseup', endDive); dBtn.addEventListener('mouseleave', endDive);
                dBtn.addEventListener('touchstart', startDive, {passive: false}); dBtn.addEventListener('touchend', endDive, {passive: false});
            }

            init3D() {
                this.renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('game-canvas'), antialias: true });
                this.renderer.setSize(innerWidth, innerHeight);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;

                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 6000);

                // Lights Placeholder
                this.hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
                this.scene.add(this.hemi);
                this.sun = new THREE.DirectionalLight(0xffffff, 1.5);
                this.sun.position.set(-100, 300, -100);
                this.sun.castShadow = true;
                this.sun.shadow.mapSize.set(2048, 2048);
                this.sun.shadow.camera.far = 4000;
                const d = 1000;
                this.sun.shadow.camera.left = -d; this.sun.shadow.camera.right = d;
                this.sun.shadow.camera.top = d; this.sun.shadow.camera.bottom = -d;
                this.scene.add(this.sun);

                this.buildBird();
                this.loadBiome(0); // Load default world
                this.buildSpeedLines();

                window.addEventListener('resize', () => {
                    this.camera.aspect = innerWidth/innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(innerWidth, innerHeight);
                });
                this.loop();
            }

            loadBiome(index) {
                const data = BIOMES[index];
                document.getElementById('world-name').innerText = data.name;

                // 1. Atmosphere
                this.scene.background = new THREE.Color(data.sky);
                this.scene.fog = new THREE.FogExp2(data.fog, 0.0008);
                this.hemi.color.setHex(data.hemi);
                this.sun.color.setHex(data.sun);

                // 2. Clear old terrain
                this.envObjects.forEach(obj => this.scene.remove(obj));
                this.envObjects = [];

                // 3. Build New Terrain
                // Ground
                const gGeo = new THREE.PlaneGeometry(WORLD_SIZE, WORLD_SIZE, 128, 128);
                const pos = gGeo.attributes.position;
                for(let i=0; i<pos.count; i++) {
                    const x = pos.getX(i); const y = pos.getY(i);
                    pos.setZ(i, (Math.sin(x/800)*Math.cos(y/800)*150) + Math.random()*5);
                }
                gGeo.computeVertexNormals();
                const ground = new THREE.Mesh(gGeo, new THREE.MeshStandardMaterial({color: data.ground, roughness: 1}));
                ground.rotation.x = -Math.PI/2; ground.position.y = -150; ground.receiveShadow = true;
                this.scene.add(ground);
                this.envObjects.push(ground);

                // Trees
                const tGeo = new THREE.ConeGeometry(20, 80, 6); tGeo.translate(0, 40, 0);
                const tMat = new THREE.MeshStandardMaterial({color: data.treeColor});
                if(data.name === "NEON GRID") { tMat.emissive = new THREE.Color(data.treeColor); tMat.emissiveIntensity = 0.5; }
                
                const forest = new THREE.InstancedMesh(tGeo, tMat, TREE_COUNT);
                forest.castShadow = true; forest.receiveShadow = true;
                
                const dummy = new THREE.Object3D();
                for(let i=0; i<TREE_COUNT; i++) {
                    dummy.position.set((Math.random()-0.5)*WORLD_SIZE, -150, (Math.random()-0.5)*WORLD_SIZE);
                    const s = 1 + Math.random()*3;
                    dummy.scale.set(s, s*(0.8+Math.random()), s);
                    dummy.updateMatrix();
                    forest.setMatrixAt(i, dummy.matrix);
                }
                this.scene.add(forest);
                this.envObjects.push(forest);

                // Rain
                if(data.rain) {
                    const rGeo = new THREE.BufferGeometry();
                    const rPos = [];
                    for(let i=0; i<5000; i++) rPos.push((Math.random()-0.5)*400, (Math.random()-0.5)*200, (Math.random()-0.5)*400);
                    rGeo.setAttribute('position', new THREE.Float32BufferAttribute(rPos, 3));
                    this.rain = new THREE.Points(rGeo, new THREE.PointsMaterial({color:0xaaaaaa, size:0.5, transparent:true}));
                    this.scene.add(this.rain);
                    this.envObjects.push(this.rain);
                } else {
                    this.rain = null;
                }
            }

            buildBird() {
                this.bird = new THREE.Group();
                const mat = new THREE.MeshStandardMaterial({color: 0x5d4037});
                const matGold = new THREE.MeshStandardMaterial({color: 0xffb300});
                const body = new THREE.Mesh(new THREE.ConeGeometry(0.6, 2, 16), mat);
                body.rotation.x = -Math.PI/2; body.castShadow = true;
                this.bird.add(body);
                const head = new THREE.Mesh(new THREE.SphereGeometry(0.45), mat);
                head.position.set(0, 0.2, -0.8); this.bird.add(head);
                const beak = new THREE.Mesh(new THREE.ConeGeometry(0.15, 0.6, 8), matGold);
                beak.rotation.x = -Math.PI/2; beak.position.set(0, -0.1, -1.2); this.bird.add(beak);
                const wGeo = new THREE.BoxGeometry(2.8, 0.1, 1); wGeo.translate(1.4, 0, 0);
                this.wingL = new THREE.Mesh(wGeo, mat); this.wingL.position.set(0.2, 0.2, -0.3);
                this.wingR = new THREE.Mesh(wGeo, mat); this.wingR.position.set(-0.2, 0.2, -0.3); this.wingR.scale.x = -1;
                this.wingL.castShadow = true; this.wingR.castShadow = true;
                this.bird.add(this.wingL, this.wingR);
                this.scene.add(this.bird);
            }

            buildSpeedLines() {
                const geo = new THREE.BufferGeometry();
                const pos = [];
                for(let i=0; i<PARTICLE_COUNT; i++) pos.push((Math.random()-0.5)*100, (Math.random()-0.5)*50, (Math.random()-0.5)*100);
                geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
                this.speedLines = new THREE.Points(geo, new THREE.PointsMaterial({color: 0xffffff, size: 0.5, transparent: true, opacity: 0}));
                this.bird.add(this.speedLines);
            }

            loop() {
                requestAnimationFrame(() => this.loop());
                if(this.state.paused) return;
                this.state.time += 0.02;

                // Physics
                if(this.input.dive && this.state.stamina > 0) this.state.stamina -= 0.5;
                else if(!this.input.dive) this.state.stamina = Math.min(100, this.state.stamina + 0.15);
                
                const isDiving = (this.input.dive && this.state.stamina > 0);
                let tSpeed = isDiving ? 5.0 : (this.input.y>0 ? 2.5 : 1.2);
                this.state.speed += (tSpeed - this.state.speed) * 0.05;

                this.bird.translateZ(-this.state.speed);
                this.bird.rotation.z += (this.input.x*-0.8 - this.bird.rotation.z) * 0.08;
                this.bird.rotation.x += ((this.input.dive?-0.6:this.input.y*0.5) - this.bird.rotation.x) * 0.1;
                this.bird.rotation.y += this.bird.rotation.z * 0.04;

                // Camera
                const cOff = new THREE.Vector3(0, 7, 18 + this.state.speed*2);
                cOff.applyMatrix4(this.bird.matrixWorld);
                this.camera.position.lerp(cOff, 0.1);
                this.camera.lookAt(this.bird.position);
                
                // Effects
                if(isDiving) { this.speedLines.material.opacity = 0.6; this.speedLines.scale.z = 20; } 
                else { this.speedLines.material.opacity *= 0.9; }

                const flap = Math.sin(this.state.time * 10) * 0.5;
                this.wingL.rotation.z = isDiving ? -0.5 : flap;
                this.wingR.rotation.z = isDiving ? 0.5 : -flap;

                if(this.bird.position.length() > WORLD_SIZE/2) {
                    this.bird.position.set(0,150,0);
                }
                
                // Rain
                if(this.rain) {
                    this.rain.position.copy(this.bird.position);
                    this.rain.position.y += 20;
                    const pos = this.rain.geometry.attributes.position.array;
                    for(let i=1; i<pos.length; i+=3) {
                        pos[i] -= 3; if(pos[i] < -50) pos[i] = 50;
                    }
                    this.rain.geometry.attributes.position.needsUpdate = true;
                }

                // UI
                document.getElementById('stamina-bar').style.width = this.state.stamina + '%';
                document.getElementById('spd').innerText = Math.floor(this.state.speed*50);
                document.getElementById('alt').innerText = Math.floor(this.bird.position.y+150);
                document.getElementById('score').innerText = Math.floor(this.state.time * 10);

                this.audio.update(this.state.speed);
                this.renderer.render(this.scene, this.camera);
            }
        }

        window.onload = () => new Game();
    </script>
</body>
</html>